#ifndef VARIANT_IMPORTER_H_
#define VARIANT_IMPORTER_H_

#include <unordered_map>

#include "algorithm/compression/compression_manager.h"
#include "algorithm/compression/genotype_encoder.h"
#include "algorithm/timer.h"
#include "containers/variant_block.h"
#include "core/variant_import_writer.h"
#include "core/variant_importer_container_stats.h"
#include "index/variant_index_entry.h"
#include "index/variant_index_meta_entry.h"
#include "io/vcf_utils.h"
#include "support/helpers.h"
#include "algorithm/digest/variant_digest_manager.h"
#include "core/footer/footer.h"
#include "algorithm/encryption/encryption_decorator.h"
#include "algorithm/permutation/genotype_sorter.h"

#include "core/variant_import_settings.h"

namespace tachyon {

/**<
 * Slave worker instantiation of VariantImporter. Used exclusively during htslib
 * Vcf importing. Data has to be provided through the cyclic queue generated by the
 * appropriate producer.
 */
class VcfImporterSlave {
public:
	typedef VcfImporterSlave                self_type;
	typedef VariantImportWriterInterface    writer_type;
	typedef io::BasicBuffer                 buffer_type;
	typedef index::VariantIndexEntry        index_entry_type;
	typedef io::VcfHeader                   vcf_header_type;
	typedef containers::VcfContainer        vcf_container_type;
	typedef algorithm::CompressionManager   compression_manager_type;
	typedef algorithm::GenotypeSorter       radix_sorter_type;
	typedef algorithm::GenotypeEncoder      gt_encoder_type;
	typedef containers::DataContainer       stream_container;
	typedef containers::VariantBlock        block_type;
	typedef support::VariantImporterContainerStats import_stats_type;
	typedef core::MetaEntry                 meta_type;
	typedef VariantImporterSettings         settings_type;
	typedef std::unordered_map<uint32_t, uint32_t> reorder_map_type;
	typedef std::unordered_map<uint64_t, uint32_t> hash_map_type;

public:
	VcfImporterSlave() : n_blocks_processed(0), block_id(0), vcf_header_(nullptr), GT_available_(false){}
	VcfImporterSlave(const settings_type& settings) : n_blocks_processed(0), block_id(0), vcf_header_(nullptr), GT_available_(false){}
	VcfImporterSlave(const self_type& other) = delete;
	VcfImporterSlave(self_type&& other) noexcept = delete;
	VcfImporterSlave& operator=(const self_type& other) = delete;
	VcfImporterSlave& operator=(self_type&& other) = delete;
	~VcfImporterSlave(){
		// do not delete vcf_header, it is not owned by this class
	}

	VcfImporterSlave& operator+=(const VcfImporterSlave& other){
		this->n_blocks_processed += other.n_blocks_processed;
		this->index += other.index;
		return(*this);
	}

	/**<
	 * Import the contents from a provided VcfContainer and target block id
	 * into the local VariantBlock while preparing it for writing.
	 * @param container
	 * @param block_id
	 * @return
	 */
	bool Add(vcf_container_type& container, const uint32_t block_id){
		// Clear current data.
		this->block.clear();
		this->index_entry.reset();

		// Assign new block id. This is provided by the producer.
		this->block_id = block_id;
		this->index_entry.blockID = block_id;

		if(this->n_blocks_processed++ == 0){
			// Allocate containers and offsets for this file.
			// This is not strictly necessary but prevents nasty resize
			// calls in most cases.
			this->block.Allocate(this->vcf_header_->info_fields_.size(),
								 this->vcf_header_->format_fields_.size(),
								 this->vcf_header_->filter_fields_.size());

			// Resize containers
			const uint32_t resize_to = this->settings_.checkpoint_n_snps * sizeof(uint32_t) * 2; // small initial allocation
			this->block.resize(resize_to);
		}

		// This pointer here is borrowed from the PPA manager
		// during import stages. Do not destroy the target block
		// before finishing with this.
		this->block.gt_ppa = &this->permutator.permutation_array;

		if(this->GT_available_ && this->settings_.permute_genotypes){
			// Only store the permutation array if the number of samples
			// are greater then one (1).
			if(this->vcf_header_->GetNumberSamples() > 1){
				if(this->permutator.Build(container, *this->vcf_header_) == false)
					return false;

				this->block.header.controller.hasGTPermuted = true;
			}
		}

		if(this->AddRecords(container) == false) return false;

		this->block.header.controller.hasGT  = this->GT_available_;
		this->block.header.n_variants        = container.sizeWithoutCarryOver();
		this->block.UpdateContainers();

		// Perform compression using standard parameters.
		if(!this->compression_manager.Compress(this->block, this->settings_.compression_level, 6)){
			std::cerr << utility::timestamp("ERROR","COMPRESSION") << "Failed to compress..." << std::endl;
			return false;
		}

		// Encrypt the variant block if desired.
		if(this->settings_.encrypt_data){
			// Generate field-unique identifiers.
			//this->GenerateIdentifiers();

			// Start encryption.
			//this->block.header.controller.anyEncrypted = true;
			//if(!encryption_manager.encrypt(this->block, keychain, YON_ENCRYPTION_AES_256_GCM)){
			//	std::cerr << utility::timestamp("ERROR","COMPRESSION") << "Failed to encrypt..." << std::endl;
			//}
		}

		this->block.Finalize();
		// After all compression and writing is finished the header
		// offsets are themselves compressed and stored in the block.
		this->block.PackFooter(); // Pack footer into buffer.
		this->compression_manager.zstd_codec.Compress(block.footer_support);

		return true;
	}

	bool AddRecords(const vcf_container_type& container);
	bool AddRecord(const vcf_container_type& container, const uint32_t position, meta_type& meta);
	bool AddVcfInfo(const bcf1_t* record, meta_type& meta);
	bool AddVcfFormatInfo(const bcf1_t* record, meta_type& meta);
	bool AddVcfFilterInfo(const bcf1_t* record, meta_type& meta);
	bool IndexRecord(const bcf1_t* record, const meta_type& meta);
	bool AddVcfInfoPattern(const std::vector<int>& pattern, meta_type& meta);
	bool AddVcfFormatPattern(const std::vector<int>& pattern, meta_type& meta);
	bool AddVcfFilterPattern(const std::vector<int>& pattern, meta_type& meta);
	bool AddGenotypes(const vcf_container_type& container, meta_type* meta_entries);

	//bool GenerateIdentifiers(void);

	inline void SetVcfHeader(vcf_header_type* header){
		this->vcf_header_ = header;
		// Setup genotype permuter and genotype encoder.
		this->permutator.SetSamples(header->GetNumberSamples());
		this->encoder.SetSamples(header->GetNumberSamples());
	}

public:
	uint32_t n_blocks_processed; // number of blocks processed
	uint32_t block_id; // local block id
	index::Index index; // local index
	vcf_header_type* vcf_header_; // global header
	settings_type settings_; // internal settings
	bool GT_available_; // genotypes available
	index_entry_type  index_entry; // streaming index entry
	radix_sorter_type permutator;  // GT permuter
	gt_encoder_type   encoder;     // RLE packer
	compression_manager_type compression_manager; // General compression manager
	block_type block; // Local data container
	// Maps from htslib vcf header to yon header.
	reorder_map_type filter_reorder_map_;
	reorder_map_type info_reorder_map_;
	reorder_map_type format_reorder_map_;
	reorder_map_type contig_reorder_map_;
};

class VariantImporter {
public:
	typedef VariantImporter                 self_type;
	typedef VariantImportWriterInterface    writer_interface_type;
	typedef VariantImportWriterFile         writer_file_type;
	typedef VariantImportWriterStream       writer_stream_type;
	typedef io::BasicBuffer                 buffer_type;
	typedef index::VariantIndexEntry        index_entry_type;
	typedef io::VcfReader                   vcf_reader_type;
	typedef containers::VcfContainer        vcf_container_type;
	typedef algorithm::CompressionManager   compression_manager_type;
	typedef algorithm::GenotypeSorter       radix_sorter_type;
	typedef algorithm::GenotypeEncoder      gt_encoder_type;
	typedef containers::DataContainer       stream_container;
	typedef containers::VariantBlock        block_type;
	typedef support::VariantImporterContainerStats import_stats_type;
	typedef core::MetaEntry                 meta_type;
	typedef VariantImporterSettings         settings_type;
	typedef std::unordered_map<uint32_t, uint32_t>    reorder_map_type;
	typedef std::unordered_map<uint64_t, uint32_t>    hash_map_type;

public:
	VariantImporter();
	VariantImporter(const settings_type& settings);
	~VariantImporter();

	bool Build();
	bool BuildParallel();

	void clear(void);

	inline void SetWriterTypeFile(void)  { this->writer = new writer_file_type;   }
	inline void SetWriterTypeStream(void){ this->writer = new writer_stream_type; }

private:
	bool WriteFinal(algorithm::VariantDigestManager& checksums);
	bool WriteKeychain(const encryption::Keychain<>& keychain);
	bool WriteYonHeader();
	void UpdateHeaderImport(VariantHeader& header);

private:
	settings_type settings_; // import settings
	bool GT_available_;

	// Stats
	import_stats_type stats_basic;
	import_stats_type stats_info;
	import_stats_type stats_format;

	// Read/write fields
	writer_interface_type* writer; // writer

	compression_manager_type compression_manager;

	// Map from BCF global FORMAT/INFO/FILTER IDX to local IDX such that
	// FORMAT maps to [0, f-1], and INFO maps to [0, i-1] and FILTER to
	// [0,l-1] and where f+i+l = n, where n is the total number of fields.
	//
	//                    Global    Local
	// std::unordered_map<uint32_t, uint32_t> filter_reorder_map_;
	reorder_map_type filter_reorder_map_;
	reorder_map_type info_reorder_map_;
	reorder_map_type format_reorder_map_;
	reorder_map_type contig_reorder_map_;

	std::unique_ptr<vcf_reader_type> vcf_reader_;
	VariantHeader yon_header_;

	hash_map_type block_hash_map;
};

} /* namespace Tachyon */

#endif /* VARIANT_IMPORTER_H_ */
