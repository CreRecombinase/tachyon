#ifndef ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_
#define ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_

#include "containers/variant_container.h"
#include "core/ts_tv_object.h"

namespace tachyon {

class VariantBaseSlaveInterface {
public:
	VariantBaseSlaveInterface(){}
	virtual ~VariantBaseSlaveInterface(){}

	virtual bool Unpack(containers::VariantBlock*& dc) =0;

public:

};

class VariantBaseSlave : public VariantBaseSlaveInterface {
public:
	VariantBaseSlave(void) : global_header(nullptr){}
	virtual ~VariantBaseSlave(){}

	/**<
	 * Basic unpacking function for VariantBlock data. Attempts
	 * to move the data to the local VariantBlockContainer followed
	 * by decryption and decompression.
	 * @param dc Src VariantBlock pointer reference as provided by the shared data pool generated by a producer.
	 * @return   Returns TRUE upon success or FALSE otherwise.
	 */
	virtual bool Unpack(containers::VariantBlock*& dc){
		vc.GetBlock() = std::move(*dc); // copy test
		delete dc;
		dc = nullptr;

		/*
		if(vc.AnyEncrypted()){
			if(this->keychain.size() == 0){
				std::cerr << utility::timestamp("ERROR", "DECRYPTION") << "Data is encrypted but no keychain was provided!" << std::endl;
				return false;
			}

			encryption_manager_type encryption_manager;
			if(!encryption_manager.Decrypt(vc.GetBlock(), this->keychain)){
				std::cerr << utility::timestamp("ERROR", "DECRYPTION") << "Failed decryption!" << std::endl;
				return false;
			}
		}
		*/

		// Internally decompress available data
		if(!this->codec_manager.Decompress(vc.GetBlock())){
			std::cerr << utility::timestamp("ERROR", "COMPRESSION") << "Failed decompression!" << std::endl;
			return false;
		}

		return(true);
	}

public:
	VariantHeader* global_header;
	containers::VariantBlockContainer vc;
	DataBlockSettings settings;
	algorithm::CompressionManager codec_manager;
};

class VariantSlavePerformance : public VariantBaseSlave {
protected:
	typedef VariantBaseSlave parent_type;

public:
	VariantSlavePerformance() : data_loaded(0), data_uncompressed(0){}

	VariantSlavePerformance& operator+=(const VariantSlavePerformance& other){
		this->data_loaded += other.data_loaded;
		this->data_uncompressed += other.data_uncompressed;
		return(*this);
	}

	bool LoadData(containers::VariantBlock*& dc){
		// Move data over to local VariantBlockContainer.
		vc.GetBlock() = std::move(*dc); // copy test
		delete dc;
		dc = nullptr;

		// Update data read.
		this->data_loaded += vc.GetBlock().GetCompressedSize();
		return true;
	}

	bool UncompressData(containers::VariantBlock*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}
		// Update data read.
		this->data_loaded += vc.GetBlock().GetCompressedSize();
		this->data_uncompressed += vc.GetBlock().GetUncompressedSize();

		return true;
	}

	bool EvaluateData(containers::VariantBlock*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}
		// Update data read.
		this->data_loaded += vc.GetBlock().GetCompressedSize();
		this->data_uncompressed += vc.GetBlock().GetUncompressedSize();

		VariantContainer ivc(vc.GetBlock().header.n_variants);
		ivc.Build(vc.GetBlock(), *this->global_header);

		return true;
	}

	bool EvaluateRecords(containers::VariantBlock*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}

		// Update data read.
		this->data_loaded += vc.GetBlock().GetCompressedSize();
		this->data_uncompressed += vc.GetBlock().GetUncompressedSize();

		VariantContainer ivc(vc.GetBlock().header.n_variants);
		ivc.Build(vc.GetBlock(), *this->global_header);

		return true;
	}

public:
	uint64_t data_loaded;
	uint64_t data_uncompressed;
};

class VariantSlaveTsTv : public VariantBaseSlave {
protected:
	typedef VariantBaseSlave parent_type;

public:
	VariantSlaveTsTv(void){}
	~VariantSlaveTsTv(){}

	bool GatherGenotypeStatistics(containers::VariantBlock*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}

		if(this->vc.GetBlock().header.controller.has_gt == false)
			return true;

		VariantContainer ivc(vc.GetBlock().header.n_variants);
		assert(this->global_header != nullptr);
		ivc.Build(vc.GetBlock(), *this->global_header);

		s_local.reset();
		for(uint32_t i = 0; i < ivc.size(); ++i){
			if(ivc[i].is_loaded_gt){
				//entries[i].gt->ExpandExternal(this->vc.GetAllocatedGenotypeMemory());
				//s.Update(entries[i], this->vc.GetAllocatedGenotypeMemory());
				s_local.Update(ivc[i]);
			}
		}


		assert(vc.GetBlock().gt_ppa != nullptr);

		if(this->vc.GetBlock().header.controller.has_gt_permuted){
			// Reduce function for adding together TsTv objects
			// in the sample order as described in the local
			// permutation array.
			s.Add(s_local, *vc.GetBlock().gt_ppa);
		} else
			s += s_local;

		return true;
	}

public:
	yon_stats_tstv s;
	yon_stats_tstv s_local;
};

}




#endif /* ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_ */
