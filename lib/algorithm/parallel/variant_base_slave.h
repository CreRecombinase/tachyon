#ifndef ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_
#define ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_

#include "variant_container.h"
#include "algorithm/compression/compression_manager.h"

namespace tachyon {

class VariantBaseSlaveInterface {
public:
	VariantBaseSlaveInterface(){}
	virtual ~VariantBaseSlaveInterface(){}

	virtual bool Unpack(yon1_vb_t*& dc) =0;

public:

};

class VariantBaseSlave : public VariantBaseSlaveInterface {
public:
	VariantBaseSlave(void) : global_header(nullptr), gt_exp(nullptr){}
	virtual ~VariantBaseSlave(){ delete [] gt_exp; }

	/**<
	 * Basic unpacking function for VariantBlock data. Attempts
	 * to move the data to the local VariantBlockContainer followed
	 * by decryption and decompression.
	 * @param dc Src VariantBlock pointer reference as provided by the shared data pool generated by a producer.
	 * @return   Returns TRUE upon success or FALSE otherwise.
	 */
	virtual bool Unpack(yon1_vb_t*& dc){
		vc = std::move(*dc); // copy test
		delete dc;
		dc = nullptr;

		/*
		if(vc.AnyEncrypted()){
			if(this->keychain.size() == 0){
				std::cerr << utility::timestamp("ERROR", "DECRYPTION") << "Data is encrypted but no keychain was provided!" << std::endl;
				return false;
			}

			encryption_manager_type encryption_manager;
			if(!encryption_manager.Decrypt(vc.GetBlock(), this->keychain)){
				std::cerr << utility::timestamp("ERROR", "DECRYPTION") << "Failed decryption!" << std::endl;
				return false;
			}
		}
		*/

		// Internally decompress available data
		if(!this->codec_manager.Decompress(vc)){
			std::cerr << utility::timestamp("ERROR", "COMPRESSION") << "Failed decompression!" << std::endl;
			return false;
		}

		return(true);
	}

public:
	yon_vnt_hdr_t* global_header;
	yon1_vb_t vc;
	yon_gt_rcd* gt_exp;
	DataBlockSettings settings;
	algorithm::CompressionManager codec_manager;
};

class VariantSlavePerformance : public VariantBaseSlave {
protected:
	typedef VariantBaseSlave parent_type;

public:
	VariantSlavePerformance() : data_loaded(0), data_uncompressed(0){}

	VariantSlavePerformance& operator+=(const VariantSlavePerformance& other){
		this->data_loaded += other.data_loaded;
		this->data_uncompressed += other.data_uncompressed;
		return(*this);
	}

	bool LoadData(yon1_vb_t*& dc){
		// Move data over to local VariantBlockContainer.
		vc = std::move(*dc); // copy test
		delete dc;
		dc = nullptr;

		// Update data read.
		this->data_loaded += vc.GetCompressedSize();
		return true;
	}

	bool UncompressData(yon1_vb_t*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}
		// Update data read.
		this->data_loaded += vc.GetCompressedSize();
		this->data_uncompressed += vc.GetUncompressedSize();

		return true;
	}

	bool EvaluateData(yon1_vb_t*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}
		// Update data read.
		this->data_loaded += vc.GetCompressedSize();
		this->data_uncompressed += vc.GetUncompressedSize();

		yon1_vc_t ivc(vc.header.n_variants);
		ivc.Build(vc, *this->global_header);

		return true;
	}

	bool EvaluateRecords(yon1_vb_t*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}

		// Update data read.
		this->data_loaded += vc.GetCompressedSize();
		this->data_uncompressed += vc.GetUncompressedSize();

		yon1_vc_t ivc(vc.header.n_variants);
		ivc.Build(vc, *this->global_header);

		return true;
	}

public:
	uint64_t data_loaded;
	uint64_t data_uncompressed;
};

class VariantSlaveTsTv : public VariantBaseSlave {
protected:
	typedef VariantBaseSlave parent_type;

public:
	VariantSlaveTsTv(void){}
	~VariantSlaveTsTv(){}

	bool GatherGenotypeStatistics(yon1_vb_t*& dc){
		if(parent_type::Unpack(dc) == false){
			std::cerr << "returning becuase of eerror" << std::endl;
			return false;
		}

		if(this->vc.header.controller.has_gt == false)
			return true;

		yon1_vc_t ivc(vc, *this->global_header);

		s_local.reset();
		for(uint32_t i = 0; i < ivc.size(); ++i){
			if(ivc[i].is_loaded_gt){
				s_local.Update(ivc[i]);
			}
		}


		assert(vc.gt_ppa != nullptr);

		if(this->vc.header.controller.has_gt_permuted){
			// Reduce function for adding together TsTv objects
			// in the sample order as described in the local
			// permutation array.
			s.Add(s_local, vc.gt_ppa);
		} else
			s += s_local;

		return true;
	}

public:
	yon_stats_tstv s;
	yon_stats_tstv s_local;
};

}




#endif /* ALGORITHM_PARALLEL_VARIANT_BASE_SLAVE_H_ */
